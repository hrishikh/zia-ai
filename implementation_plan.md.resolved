# Zia AI — Production System Architecture

> Transforming the existing CLI prototype into a production-grade, voice-first, OAuth-secured AI assistant with action-based architecture.

---

## 1. System Architecture

### High-Level Architecture

```mermaid
graph TB
    subgraph Client["Frontend (Next.js)"]
        UI["Dashboard UI"]
        VoiceUI["Voice Interface<br/>(Web Speech API)"]
        ConfirmModal["Confirmation Modal"]
        AuthUI["OAuth Connection Manager"]
    end

    subgraph Gateway["API Gateway (Nginx)"]
        SSL["TLS Termination"]
        RL["Rate Limiter"]
    end

    subgraph Backend["Backend (FastAPI)"]
        API["REST API Router"]
        WS["WebSocket Server"]
        ActionEngine["Action Engine"]
        ConfirmEngine["Confirmation Rules Engine"]
        AuthMgr["Auth Manager"]
        AuditSvc["Audit Service"]
        Scheduler["Task Scheduler"]
    end

    subgraph Executors["Action Executors"]
        GmailEx["Gmail Executor"]
        TwilioEx["Twilio Executor"]
        FileEx["Filesystem Executor"]
        BrowserEx["Browser Executor"]
        SystemEx["System CMD Executor"]
        MacroEx["Macro Executor"]
    end

    subgraph Storage["Data Layer"]
        PG["PostgreSQL"]
        Redis["Redis (Cache + Queue)"]
        Keyring["OS Keyring / Vault"]
    end

    subgraph External["External Services"]
        Google["Google OAuth2 + Gmail API"]
        Twilio["Twilio Voice + SMS + WhatsApp"]
        Spotify["Spotify API"]
    end

    Client -->|HTTPS| Gateway
    Gateway --> API
    Gateway --> WS
    API --> ActionEngine
    API --> AuthMgr
    API --> AuditSvc
    WS --> ActionEngine
    ActionEngine --> ConfirmEngine
    ActionEngine --> Executors
    ConfirmEngine -->|"check rules"| PG
    Executors --> External
    AuthMgr --> Keyring
    AuthMgr --> PG
    AuditSvc --> PG
    ActionEngine --> Redis
```

### Request Lifecycle

```mermaid
sequenceDiagram
    participant U as User (Browser)
    participant F as Frontend (Next.js)
    participant A as FastAPI Backend
    participant CE as Confirmation Engine
    participant AE as Action Engine
    participant EX as Executor
    participant DB as PostgreSQL
    participant AL as Audit Logger

    U->>F: Voice/Text Command
    F->>A: POST /api/v1/actions/execute
    A->>A: Authenticate JWT
    A->>AE: Parse Intent → Action Schema
    AE->>CE: Evaluate Confirmation Rules
    
    alt Requires Confirmation
        CE-->>A: Return pending_confirmation + token
        A-->>F: 202 Accepted {confirmation_token, action_preview}
        F->>U: Show Confirmation Modal
        U->>F: Confirm / Reject
        F->>A: POST /api/v1/actions/confirm {confirmation_token}
        A->>AE: Execute with confirmed token
    else No Confirmation Needed
        CE-->>AE: Approved (auto)
    end

    AE->>EX: Execute Action
    EX-->>AE: Result
    AE->>AL: Log to audit trail
    AL->>DB: INSERT audit_log
    AE-->>A: ActionResult
    A-->>F: 200 OK {result}
    F-->>U: Display Result + Speak
```

---

## 2. Folder Structure

```
d:\Zia AI\
├── backend/                          # FastAPI Application
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py                   # FastAPI entrypoint, middleware, lifespan
│   │   ├── config.py                 # Pydantic Settings (env-based config)
│   │   ├── database.py               # SQLAlchemy engine + session factory
│   │   │
│   │   ├── api/                      # API layer
│   │   │   ├── __init__.py
│   │   │   ├── deps.py               # Dependency injection (get_db, get_user)
│   │   │   └── v1/
│   │   │       ├── __init__.py
│   │   │       ├── router.py         # Top-level v1 router
│   │   │       ├── actions.py        # POST /actions/execute, /actions/confirm
│   │   │       ├── auth.py           # OAuth2 flows, token mgmt, revocation
│   │   │       ├── audit.py          # GET /audit/logs, /audit/export
│   │   │       ├── admin.py          # Service mgmt, user settings
│   │   │       └── websocket.py      # WebSocket for voice + realtime
│   │   │
│   │   ├── core/                     # Business logic
│   │   │   ├── __init__.py
│   │   │   ├── action_engine.py      # Intent parsing + action routing
│   │   │   ├── action_registry.py    # Registered action schemas
│   │   │   ├── confirmation.py       # Confirmation rules engine
│   │   │   └── security.py           # JWT handling, password hashing, RBAC
│   │   │
│   │   ├── executors/                # Isolated action executors
│   │   │   ├── __init__.py
│   │   │   ├── base.py               # Abstract BaseExecutor
│   │   │   ├── gmail.py              # Gmail OAuth2 executor
│   │   │   ├── twilio_voice.py       # Twilio calls
│   │   │   ├── twilio_whatsapp.py    # Twilio WhatsApp
│   │   │   ├── filesystem.py         # File read/search/open
│   │   │   ├── browser.py            # Selenium browser control
│   │   │   ├── system.py             # Non-privileged system commands
│   │   │   └── macros.py             # Work Mode + custom routines
│   │   │
│   │   ├── models/                   # SQLAlchemy ORM models
│   │   │   ├── __init__.py
│   │   │   ├── user.py
│   │   │   ├── action_log.py
│   │   │   ├── oauth_token.py
│   │   │   ├── confirmation.py
│   │   │   └── connected_service.py
│   │   │
│   │   ├── schemas/                  # Pydantic request/response models
│   │   │   ├── __init__.py
│   │   │   ├── action.py             # ActionRequest, ActionResponse, ActionResult
│   │   │   ├── auth.py               # LoginRequest, TokenResponse, OAuthCallback
│   │   │   ├── audit.py              # AuditLogEntry, AuditExport
│   │   │   └── confirmation.py       # ConfirmationRequest, ConfirmationRule
│   │   │
│   │   └── services/                 # Service layer (business logic helpers)
│   │       ├── __init__.py
│   │       ├── audit_service.py      # Audit logging
│   │       ├── auth_service.py       # OAuth2 token storage + refresh + revocation
│   │       └── notification.py       # Internal notifications
│   │
│   ├── alembic/                      # Database migrations
│   │   ├── alembic.ini
│   │   ├── env.py
│   │   └── versions/
│   │
│   ├── tests/                        # Backend tests
│   │   ├── conftest.py
│   │   ├── test_actions.py
│   │   ├── test_auth.py
│   │   └── test_confirmation.py
│   │
│   ├── Dockerfile
│   ├── requirements.txt
│   ├── .env.example
│   └── pyproject.toml
│
├── frontend/                         # Next.js Application
│   ├── src/
│   │   ├── app/                      # App Router
│   │   │   ├── layout.tsx
│   │   │   ├── page.tsx              # Dashboard / Main assistant view
│   │   │   ├── auth/
│   │   │   │   ├── login/page.tsx
│   │   │   │   └── callback/page.tsx # OAuth callback handler
│   │   │   ├── settings/page.tsx     # Service connections + preferences
│   │   │   └── audit/page.tsx        # Audit log viewer
│   │   │
│   │   ├── components/
│   │   │   ├── VoiceOrb.tsx          # Voice input/output orb (Web Speech API)
│   │   │   ├── ActionFeed.tsx        # Live action feed
│   │   │   ├── ConfirmDialog.tsx     # Confirmation modal
│   │   │   ├── ServiceCard.tsx       # OAuth service connection card
│   │   │   └── AuditTable.tsx        # Audit log table
│   │   │
│   │   ├── hooks/
│   │   │   ├── useVoice.ts           # Web Speech API hook
│   │   │   ├── useWebSocket.ts       # WebSocket connection hook
│   │   │   └── useAuth.ts            # Auth state management
│   │   │
│   │   ├── lib/
│   │   │   ├── api.ts                # Axios/fetch wrapper
│   │   │   └── constants.ts          # API URLs, action types
│   │   │
│   │   └── styles/
│   │       └── globals.css           # Design system
│   │
│   ├── public/
│   ├── Dockerfile
│   ├── next.config.js
│   ├── package.json
│   └── tsconfig.json
│
├── deploy/                           # Deployment configs
│   ├── docker-compose.yml
│   ├── docker-compose.prod.yml
│   ├── nginx/
│   │   └── zia.conf                  # Nginx reverse proxy + SSL
│   └── scripts/
│       ├── init-db.sh
│       └── setup-ssl.sh
│
├── docs/                             # Documentation
│   └── api-spec.md
│
├── .env.example                      # Root env template
├── .gitignore
└── README.md
```

---

## 3. API Endpoint Design

### Base URL: `/api/v1`

| Method | Endpoint | Auth | Description |
|--------|----------|------|-------------|
| **Actions** |
| `POST` | `/actions/execute` | JWT | Submit an action (text or structured) |
| `POST` | `/actions/confirm` | JWT | Confirm a pending action with token |
| `POST` | `/actions/reject` | JWT | Reject a pending action |
| `GET` | `/actions/pending` | JWT | List pending confirmations |
| `GET` | `/actions/history` | JWT | Paginated action history |
| **Auth** |
| `POST` | `/auth/register` | — | Register new user |
| `POST` | `/auth/login` | — | Login → JWT |
| `POST` | `/auth/refresh` | Refresh | Refresh JWT |
| `POST` | `/auth/logout` | JWT | Invalidate tokens |
| **OAuth Services** |
| `GET` | `/oauth/{service}/authorize` | JWT | Start OAuth flow → redirect URL |
| `GET` | `/oauth/{service}/callback` | — | OAuth callback handler |
| `DELETE` | `/oauth/{service}/revoke` | JWT | Revoke service tokens |
| `GET` | `/oauth/services` | JWT | List connected services + status |
| **Audit** |
| `GET` | `/audit/logs` | JWT | Paginated audit logs (filterable) |
| `GET` | `/audit/export` | JWT | Export logs as JSON/CSV |
| `GET` | `/audit/stats` | JWT | Action stats (counts, trends) |
| **Admin** |
| `GET` | `/admin/health` | — | Health check |
| `GET` | `/admin/config` | JWT+Admin | Current config (redacted) |
| **WebSocket** |
| `WS` | `/ws/voice` | JWT (query) | Voice I/O + realtime actions |

---

## 4. Action Schema Contracts

Every action follows a strict schema. The `ActionRegistry` maps action types to their schema definitions.

### Core Action Schema

```python
# backend/app/schemas/action.py

from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, Literal
from enum import Enum
from datetime import datetime
import uuid

class RiskLevel(str, Enum):
    LOW = "low"            # File read, search, status check
    MEDIUM = "medium"      # Send message, play media
    HIGH = "high"          # Send email, make call, delete file
    CRITICAL = "critical"  # System command, bulk operations

class ActionStatus(str, Enum):
    PENDING = "pending_confirmation"
    APPROVED = "approved"
    REJECTED = "rejected"
    EXECUTING = "executing"
    COMPLETED = "completed"
    FAILED = "failed"

class ActionRequest(BaseModel):
    """Incoming action request from user"""
    input_text: Optional[str] = None         # Natural language input
    action_type: Optional[str] = None        # Direct action type
    params: Optional[Dict[str, Any]] = None  # Structured params
    source: Literal["voice", "text", "api", "macro"] = "text"

class ActionSchema(BaseModel):
    """Registered action definition"""
    action_type: str                          # e.g. "gmail.send_email"
    display_name: str                         # "Send Email"
    description: str
    risk_level: RiskLevel
    requires_confirmation: bool
    required_params: list[str]                # ["recipient", "subject", "body"]
    optional_params: list[str] = []
    executor: str                             # "gmail" → maps to GmailExecutor
    cooldown_seconds: int = 0                 # Min time between executions
    max_daily_executions: int = 0             # 0 = unlimited
    allowed_roles: list[str] = ["user"]       # RBAC

class ActionExecution(BaseModel):
    """Internal execution record"""
    execution_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    action_type: str
    params: Dict[str, Any]
    risk_level: RiskLevel
    status: ActionStatus = ActionStatus.PENDING
    confirmation_token: Optional[str] = None
    user_id: str
    created_at: datetime = Field(default_factory=datetime.utcnow)
    executed_at: Optional[datetime] = None
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

class ActionResponse(BaseModel):
    """Response returned to client"""
    execution_id: str
    status: ActionStatus
    message: str
    data: Optional[Dict[str, Any]] = None
    confirmation_required: bool = False
    confirmation_token: Optional[str] = None
    action_preview: Optional[Dict[str, Any]] = None  # What will happen
```

### Registered Action Schemas

```python
# backend/app/core/action_registry.py

ACTION_REGISTRY: dict[str, ActionSchema] = {
    "gmail.send_email": ActionSchema(
        action_type="gmail.send_email",
        display_name="Send Email",
        description="Send an email via Gmail",
        risk_level=RiskLevel.HIGH,
        requires_confirmation=True,
        required_params=["recipient", "subject", "body"],
        executor="gmail",
        max_daily_executions=50,
    ),
    "gmail.read_inbox": ActionSchema(
        action_type="gmail.read_inbox",
        display_name="Read Inbox",
        description="Read recent emails from Gmail inbox",
        risk_level=RiskLevel.LOW,
        requires_confirmation=False,
        required_params=[],
        optional_params=["limit", "query"],
        executor="gmail",
    ),
    "twilio.make_call": ActionSchema(
        action_type="twilio.make_call",
        display_name="Make Phone Call",
        description="Make a voice call via Twilio",
        risk_level=RiskLevel.HIGH,
        requires_confirmation=True,
        required_params=["recipient"],
        optional_params=["message"],
        executor="twilio_voice",
        cooldown_seconds=30,
        max_daily_executions=20,
    ),
    "twilio.send_whatsapp": ActionSchema(
        action_type="twilio.send_whatsapp",
        display_name="Send WhatsApp Message",
        description="Send a WhatsApp message via Twilio",
        risk_level=RiskLevel.MEDIUM,
        requires_confirmation=True,
        required_params=["recipient", "content"],
        executor="twilio_whatsapp",
    ),
    "filesystem.read_file": ActionSchema(
        action_type="filesystem.read_file",
        display_name="Read File",
        description="Read contents of a local file",
        risk_level=RiskLevel.LOW,
        requires_confirmation=False,
        required_params=["path"],
        executor="filesystem",
    ),
    "filesystem.search": ActionSchema(
        action_type="filesystem.search",
        display_name="Search Files",
        description="Search for files by name/content",
        risk_level=RiskLevel.LOW,
        requires_confirmation=False,
        required_params=["query"],
        optional_params=["directory", "extension"],
        executor="filesystem",
    ),
    "browser.open_url": ActionSchema(
        action_type="browser.open_url",
        display_name="Open URL",
        description="Open a URL in the browser",
        risk_level=RiskLevel.LOW,
        requires_confirmation=False,
        required_params=["url"],
        executor="browser",
    ),
    "browser.youtube_play": ActionSchema(
        action_type="browser.youtube_play",
        display_name="Play YouTube",
        description="Search and play a YouTube video",
        risk_level=RiskLevel.LOW,
        requires_confirmation=False,
        required_params=["query"],
        executor="browser",
    ),
    "system.run_command": ActionSchema(
        action_type="system.run_command",
        display_name="Run System Command",
        description="Run a non-privileged system command",
        risk_level=RiskLevel.CRITICAL,
        requires_confirmation=True,
        required_params=["command"],
        executor="system",
        max_daily_executions=100,
        allowed_roles=["admin"],
    ),
    "macro.work_mode": ActionSchema(
        action_type="macro.work_mode",
        display_name="Work Mode",
        description="Activate work routine (open workspace, play music, send notification)",
        risk_level=RiskLevel.MEDIUM,
        requires_confirmation=True,
        required_params=[],
        executor="macros",
    ),
}
```

---

## 5. Confirmation Rules Engine

```python
# backend/app/core/confirmation.py

import secrets
import hashlib
from datetime import datetime, timedelta
from typing import Optional
from app.schemas.action import ActionSchema, ActionExecution, RiskLevel, ActionStatus

# Confirmation token TTL
CONFIRMATION_TTL = timedelta(minutes=5)

class ConfirmationRule:
    """A single rule that can require confirmation."""
    def __init__(self, name: str, condition, reason: str):
        self.name = name
        self.condition = condition   # callable(action_schema, params, user) -> bool
        self.reason = reason

# ── Built-in Rules ──────────────────────────────────────
RULES = [
    ConfirmationRule(
        "high_risk",
        lambda schema, params, user: schema.risk_level in (RiskLevel.HIGH, RiskLevel.CRITICAL),
        "This action is classified as high-risk."
    ),
    ConfirmationRule(
        "schema_requires",
        lambda schema, params, user: schema.requires_confirmation,
        "This action type always requires confirmation."
    ),
    ConfirmationRule(
        "external_recipient",
        lambda schema, params, user: "recipient" in params and "@" in str(params.get("recipient", "")),
        "Action targets an external recipient."
    ),
    ConfirmationRule(
        "destructive_filesystem",
        lambda schema, params, user: schema.action_type.startswith("filesystem.") and
                                      any(kw in str(params) for kw in ["delete", "remove", "rmdir"]),
        "Destructive file operation detected."
    ),
    ConfirmationRule(
        "daily_limit_approaching",
        lambda schema, params, user: False,  # Evaluated with DB context
        "Approaching daily execution limit."
    ),
]

class ConfirmationEngine:
    """Evaluate whether an action needs confirmation and manage tokens."""

    def evaluate(self, schema: ActionSchema, params: dict, user: dict) -> tuple[bool, list[str]]:
        """Returns (requires_confirmation, list_of_triggered_rule_reasons)"""
        triggered = []
        for rule in RULES:
            if rule.condition(schema, params, user):
                triggered.append(rule.reason)
        return len(triggered) > 0, triggered

    def generate_token(self, execution: ActionExecution) -> str:
        """Generate a cryptographically secure confirmation token."""
        raw = secrets.token_urlsafe(32)
        execution.confirmation_token = hashlib.sha256(raw.encode()).hexdigest()
        return raw  # Return raw to client; store hash in DB

    def validate_token(self, raw_token: str, stored_hash: str, created_at: datetime) -> bool:
        """Validate confirmation token (hash match + TTL)."""
        if datetime.utcnow() - created_at > CONFIRMATION_TTL:
            return False
        return hashlib.sha256(raw_token.encode()).hexdigest() == stored_hash
```

---

## 6. Auth Flow Architecture

### JWT Authentication (App Login)

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Backend
    participant DB

    User->>Frontend: Enter credentials
    Frontend->>Backend: POST /auth/login {email, password}
    Backend->>DB: Verify bcrypt hash
    DB-->>Backend: User record
    Backend->>Backend: Generate JWT (access=15m) + Refresh (7d)
    Backend-->>Frontend: {access_token, refresh_token, expires_in}
    Frontend->>Frontend: Store in httpOnly cookie

    Note over Frontend,Backend: Subsequent requests include JWT in Authorization header

    Frontend->>Backend: GET /api/v1/... (Authorization: Bearer <jwt>)
    Backend->>Backend: Validate JWT signature + expiry
    Backend-->>Frontend: Response
```

### OAuth2 Service Connection (e.g. Gmail)

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Backend
    participant Google

    User->>Frontend: Click "Connect Gmail"
    Frontend->>Backend: GET /oauth/gmail/authorize
    Backend->>Backend: Generate state token + PKCE verifier
    Backend-->>Frontend: {authorization_url, state}
    Frontend->>Google: Redirect to authorization_url
    Google->>User: Consent screen
    User->>Google: Grant permission
    Google->>Backend: GET /oauth/gmail/callback?code=XXX&state=YYY
    Backend->>Backend: Validate state token
    Backend->>Google: POST token endpoint (exchange code)
    Google-->>Backend: {access_token, refresh_token, expires_in}
    Backend->>Backend: Encrypt tokens → store in DB + keyring
    Backend-->>Frontend: Redirect to /settings?connected=gmail
```

### Token Revocation

```python
# backend/app/services/auth_service.py (key method)

class AuthService:
    async def revoke_service(self, user_id: str, service: str) -> bool:
        """Revoke OAuth tokens for a connected service."""
        # 1. Load encrypted token from DB
        token_record = await self.db.get_oauth_token(user_id, service)
        if not token_record:
            return False

        # 2. Call provider's revocation endpoint
        revocation_endpoints = {
            "gmail": "https://oauth2.googleapis.com/revoke",
            "spotify": "https://accounts.spotify.com/api/token",
        }
        endpoint = revocation_endpoints.get(service)
        if endpoint:
            requests.post(endpoint, params={"token": token_record.access_token})

        # 3. Delete from DB + keyring
        await self.db.delete_oauth_token(user_id, service)
        keyring.delete_password("Zia-Assistant", f"{user_id}_{service}")

        # 4. Audit log
        await self.audit.log("oauth.revoke", user_id, {"service": service})
        return True
```

---

## 7. Database Schema (PostgreSQL)

```mermaid
erDiagram
    users ||--o{ oauth_tokens : has
    users ||--o{ action_logs : performs
    users ||--o{ pending_confirmations : has
    users ||--o{ connected_services : connects

    users {
        uuid id PK
        varchar email UK
        varchar password_hash
        varchar display_name
        varchar role "user | admin"
        boolean is_active
        timestamp created_at
        timestamp last_login
    }

    oauth_tokens {
        uuid id PK
        uuid user_id FK
        varchar service "gmail | spotify"
        text access_token_encrypted
        text refresh_token_encrypted
        timestamp expires_at
        json scopes
        timestamp created_at
        timestamp updated_at
    }

    connected_services {
        uuid id PK
        uuid user_id FK
        varchar service_name
        varchar status "active | expired | revoked"
        json metadata
        timestamp connected_at
    }

    action_logs {
        uuid id PK
        uuid user_id FK
        varchar action_type
        varchar execution_id UK
        json params "sensitive fields redacted"
        varchar risk_level
        varchar status
        varchar source "voice | text | api | macro"
        json result
        text error
        inet ip_address
        varchar user_agent
        timestamp created_at
        timestamp completed_at
        integer duration_ms
    }

    pending_confirmations {
        uuid id PK
        uuid user_id FK
        varchar execution_id UK
        varchar action_type
        json action_preview
        varchar token_hash
        json triggered_rules
        timestamp created_at
        timestamp expires_at
        varchar status "pending | confirmed | rejected | expired"
    }
```

### SQLAlchemy Models (Example)

```python
# backend/app/models/user.py

import uuid
from sqlalchemy import Column, String, Boolean, DateTime
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
from app.database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    display_name = Column(String(100))
    role = Column(String(20), default="user")  # user | admin
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    last_login = Column(DateTime(timezone=True), nullable=True)
```

---

## 8. Backend Boilerplate — Key Files

### FastAPI Entrypoint

```python
# backend/app/main.py

from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from starlette.middleware.sessions import SessionMiddleware

from app.config import settings
from app.api.v1.router import api_router
from app.database import engine, Base

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup: create tables (use Alembic in production)
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    yield
    # Shutdown: cleanup

app = FastAPI(
    title="Zia AI",
    version="1.0.0",
    description="Production AI Assistant API",
    lifespan=lifespan,
    docs_url="/api/docs" if settings.DEBUG else None,  # Disable in prod
    redoc_url=None,
)

# ── Middleware Stack ──
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
app.add_middleware(TrustedHostMiddleware, allowed_hosts=settings.ALLOWED_HOSTS)
app.add_middleware(SessionMiddleware, secret_key=settings.SECRET_KEY)

# ── Routes ──
app.include_router(api_router, prefix="/api/v1")

@app.get("/health")
async def health():
    return {"status": "healthy", "version": "1.0.0"}
```

### Configuration

```python
# backend/app/config.py

from pydantic_settings import BaseSettings
from typing import List

class Settings(BaseSettings):
    # App
    APP_NAME: str = "Zia AI"
    DEBUG: bool = False
    SECRET_KEY: str
    ALLOWED_HOSTS: List[str] = ["zia.yourdomain.com", "localhost"]
    CORS_ORIGINS: List[str] = ["https://zia.yourdomain.com"]

    # Database
    DATABASE_URL: str = "postgresql+asyncpg://zia:password@localhost:5432/zia_db"

    # Redis
    REDIS_URL: str = "redis://localhost:6379/0"

    # JWT
    JWT_SECRET: str
    JWT_ALGORITHM: str = "HS256"
    JWT_ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    JWT_REFRESH_TOKEN_EXPIRE_DAYS: int = 7

    # OAuth — Gmail
    GMAIL_CLIENT_ID: str = ""
    GMAIL_CLIENT_SECRET: str = ""
    GMAIL_REDIRECT_URI: str = "http://localhost:8000/api/v1/oauth/gmail/callback"

    # OAuth — Spotify
    SPOTIFY_CLIENT_ID: str = ""
    SPOTIFY_CLIENT_SECRET: str = ""

    # Twilio
    TWILIO_ACCOUNT_SID: str = ""
    TWILIO_AUTH_TOKEN: str = ""
    TWILIO_PHONE_NUMBER: str = ""
    TWILIO_WHATSAPP_NUMBER: str = ""

    # Security
    RATE_LIMIT_PER_MINUTE: int = 60
    MAX_CONFIRMATION_TTL_MINUTES: int = 5
    ENCRYPTION_KEY: str = ""  # Fernet key for token encryption

    class Config:
        env_file = ".env"

settings = Settings()
```

### Base Executor

```python
# backend/app/executors/base.py

from abc import ABC, abstractmethod
from typing import Dict, Any

class BaseExecutor(ABC):
    """Base class for all action executors."""

    @abstractmethod
    async def execute(self, action_type: str, params: Dict[str, Any],
                      user_id: str) -> Dict[str, Any]:
        """Execute the action and return result dict."""
        ...

    @abstractmethod
    def get_supported_actions(self) -> list[str]:
        """Return list of action_type strings this executor handles."""
        ...

    def validate_params(self, action_type: str, params: Dict[str, Any],
                        required: list[str]) -> None:
        """Validate required params are present."""
        missing = [p for p in required if p not in params or not params[p]]
        if missing:
            raise ValueError(f"Missing required parameters: {', '.join(missing)}")
```

---

## 9. Frontend Architecture (Next.js)

### Key Component: Voice Orb

The central interaction element — a pulsing orb that listens via Web Speech API, sends to WebSocket, and speaks the response.

```typescript
// frontend/src/hooks/useVoice.ts

import { useState, useCallback, useRef } from 'react';

interface UseVoiceReturn {
  isListening: boolean;
  transcript: string;
  startListening: () => void;
  stopListening: () => void;
  speak: (text: string) => void;
  isSupported: boolean;
}

export function useVoice(): UseVoiceReturn {
  const [isListening, setIsListening] = useState(false);
  const [transcript, setTranscript] = useState('');
  const recognitionRef = useRef<SpeechRecognition | null>(null);

  const isSupported = typeof window !== 'undefined' &&
    ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window);

  const startListening = useCallback(() => {
    if (!isSupported) return;
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();
    recognition.continuous = false;
    recognition.interimResults = true;
    recognition.lang = 'en-US';

    recognition.onresult = (event: SpeechRecognitionEvent) => {
      const result = Array.from(event.results)
        .map(r => r[0].transcript)
        .join('');
      setTranscript(result);
    };

    recognition.onend = () => setIsListening(false);
    recognitionRef.current = recognition;
    recognition.start();
    setIsListening(true);
  }, [isSupported]);

  const stopListening = useCallback(() => {
    recognitionRef.current?.stop();
    setIsListening(false);
  }, []);

  const speak = useCallback((text: string) => {
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.rate = 1.0;
    utterance.pitch = 1.0;
    speechSynthesis.speak(utterance);
  }, []);

  return { isListening, transcript, startListening, stopListening, speak, isSupported };
}
```

---

## 10. Deployment Plan

### Docker Compose (Production)

```yaml
# deploy/docker-compose.prod.yml

version: "3.9"

services:
  backend:
    build:
      context: ../backend
      dockerfile: Dockerfile
    env_file: ../backend/.env
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started
    restart: always
    networks:
      - zia-net

  frontend:
    build:
      context: ../frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NEXT_PUBLIC_API_URL=https://zia.yourdomain.com/api/v1
    restart: always
    networks:
      - zia-net

  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: zia_db
      POSTGRES_USER: zia
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - pg_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U zia"]
      interval: 5s
      retries: 5
    restart: always
    networks:
      - zia-net

  redis:
    image: redis:7-alpine
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    restart: always
    networks:
      - zia-net

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/zia.conf:/etc/nginx/conf.d/default.conf
      - ./certbot/conf:/etc/letsencrypt
      - ./certbot/www:/var/www/certbot
    depends_on:
      - backend
      - frontend
    restart: always
    networks:
      - zia-net

  certbot:
    image: certbot/certbot
    volumes:
      - ./certbot/conf:/etc/letsencrypt
      - ./certbot/www:/var/www/certbot
    entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h; done'"

volumes:
  pg_data:
  redis_data:

networks:
  zia-net:
    driver: bridge
```

### Nginx Config

```nginx
# deploy/nginx/zia.conf

upstream backend {
    server backend:8000;
}

upstream frontend {
    server frontend:3000;
}

# Rate limiting zone
limit_req_zone $binary_remote_addr zone=api:10m rate=30r/m;
limit_req_zone $binary_remote_addr zone=auth:10m rate=5r/m;

server {
    listen 80;
    server_name zia.yourdomain.com;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name zia.yourdomain.com;

    ssl_certificate     /etc/letsencrypt/live/zia.yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/zia.yourdomain.com/privkey.pem;

    # Security headers
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains" always;
    add_header X-Content-Type-Options nosniff always;
    add_header X-Frame-Options DENY always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' fonts.googleapis.com; font-src fonts.gstatic.com;" always;

    # API Backend
    location /api/ {
        limit_req zone=api burst=20 nodelay;
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Auth endpoints (stricter rate limit)
    location /api/v1/auth/ {
        limit_req zone=auth burst=3 nodelay;
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # WebSocket
    location /api/v1/ws/ {
        proxy_pass http://backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_read_timeout 86400;
    }

    # Frontend
    location / {
        proxy_pass http://frontend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Let's Encrypt verification
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }
}
```

### Backend Dockerfile

```dockerfile
# backend/Dockerfile

FROM python:3.12-slim AS base
WORKDIR /app

# System deps
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential libpq-dev && rm -rf /var/lib/apt/lists/*

# Python deps
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# App code
COPY . .

# Non-root user
RUN adduser --disabled-password --gecos '' appuser && chown -R appuser /app
USER appuser

EXPOSE 8000
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "4"]
```

---

## 11. Security Hardening Checklist

| # | Category | Control | Status |
|---|----------|---------|--------|
| 1 | **Auth** | bcrypt password hashing (cost=12) | ⬜ |
| 2 | **Auth** | JWT access tokens (15min TTL) | ⬜ |
| 3 | **Auth** | Refresh tokens in httpOnly cookies | ⬜ |
| 4 | **Auth** | PKCE for all OAuth2 flows | ⬜ |
| 5 | **Auth** | State parameter validation on OAuth callbacks | ⬜ |
| 6 | **Tokens** | OAuth tokens encrypted at rest (Fernet AES-128) | ⬜ |
| 7 | **Tokens** | Sensitive tokens in OS keyring when local-first | ⬜ |
| 8 | **Tokens** | Token revocation endpoint + DB cleanup | ⬜ |
| 9 | **Actions** | Confirmation tokens (SHA-256 hashed, 5min TTL) | ⬜ |
| 10 | **Actions** | All destructive actions require explicit confirmation | ⬜ |
| 11 | **Actions** | Rate limiting per user + per endpoint | ⬜ |
| 12 | **Actions** | Daily execution caps per action type | ⬜ |
| 13 | **System** | System commands restricted to allowlist | ⬜ |
| 14 | **System** | No `sudo`, no privilege escalation | ⬜ |
| 15 | **System** | Filesystem sandbox (restricted paths) | ⬜ |
| 16 | **Network** | HTTPS only (HSTS enabled) | ⬜ |
| 17 | **Network** | Nginx rate limiting (30r/m API, 5r/m auth) | ⬜ |
| 18 | **Network** | Security headers (CSP, X-Frame, X-XSS, etc.) | ⬜ |
| 19 | **Data** | Sensitive params redacted in audit logs | ⬜ |
| 20 | **Data** | [.env](file:///d:/Zia%20AI/.env) files in `.gitignore` | ⬜ |
| 21 | **Data** | No secrets in client-side code | ⬜ |
| 22 | **Infra** | Docker runs as non-root user | ⬜ |
| 23 | **Infra** | Minimal base images (python:3.12-slim) | ⬜ |
| 24 | **Infra** | DB password rotated, not in docker-compose | ⬜ |
| 25 | **Infra** | Redis password required | ⬜ |
| 26 | **Audit** | All actions logged with user, IP, timestamp | ⬜ |
| 27 | **Audit** | Failed auth attempts logged and monitored | ⬜ |
| 28 | **Audit** | Log retention policy (90 days default) | ⬜ |

---

## 12. Logging & Monitoring

### Structured Logging

```python
# backend/app/core/logging_config.py

import logging
import json
from datetime import datetime

class JSONFormatter(logging.Formatter):
    def format(self, record):
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
        }
        if record.exc_info:
            log_entry["exception"] = self.formatException(record.exc_info)
        if hasattr(record, "user_id"):
            log_entry["user_id"] = record.user_id
        if hasattr(record, "action_type"):
            log_entry["action_type"] = record.action_type
        return json.dumps(log_entry)
```

### Monitoring Stack

| Layer | Tool | Purpose |
|-------|------|---------|
| Application | Structured JSON logs | Machine-parseable, queryable |
| Metrics | Prometheus + FastAPI metrics | Request counts, latency, errors |
| Dashboards | Grafana | Visual monitoring |
| Alerts | Grafana Alerts / PagerDuty | Failure notification |
| Uptime | UptimeRobot / Healthchecks.io | External heartbeat |
| Error Tracking | Sentry | Exception capture + traces |

### Health & Metrics Endpoint

```python
# Added to main.py router

@app.get("/health")
async def health(db: AsyncSession = Depends(get_db)):
    try:
        await db.execute(text("SELECT 1"))
        db_ok = True
    except Exception:
        db_ok = False
    return {
        "status": "healthy" if db_ok else "degraded",
        "database": "connected" if db_ok else "unreachable",
        "version": "1.0.0",
        "timestamp": datetime.utcnow().isoformat()
    }
```

---

## 13. Scaling Strategy

```mermaid
graph LR
    subgraph Phase1["Phase 1: Single VPS (2-100 users)"]
        A1["1 VPS (4GB RAM)"]
        A2["Docker Compose"]
        A3["PostgreSQL + Redis local"]
        A4["Uvicorn 4 workers"]
    end

    subgraph Phase2["Phase 2: Vertical + Separation (100-1K)"]
        B1["Bigger VPS (8-16GB)"]
        B2["Managed PostgreSQL (RDS / Supabase)"]
        B3["Managed Redis (ElastiCache)"]
        B4["Uvicorn 8 workers"]
        B5["CDN for frontend (Vercel/Cloudflare)"]
    end

    subgraph Phase3["Phase 3: Horizontal (1K-10K)"]
        C1["Load Balancer (ALB / Nginx)"]
        C2["2-4 Backend containers"]
        C3["Managed DB + read replicas"]
        C4["Background worker queue (Celery + Redis)"]
        C5["S3 for audit log archival"]
        C6["Frontend on Vercel Edge"]
    end

    Phase1 --> Phase2 --> Phase3
```

| Scaling Concern | Strategy |
|-----------------|----------|
| **API throughput** | Uvicorn workers (4→8), then horizontal replicas behind LB |
| **Database** | Connection pooling (pgBouncer), read replicas, partition audit_logs by month |
| **Long-running actions** | Background task queue (Celery/ARQ + Redis) |
| **WebSocket connections** | Sticky sessions on LB, or Redis pub/sub for fanout |
| **Frontend** | Deploy to Vercel/Cloudflare Pages (zero-scaling) |
| **Audit logs** | Rotate to cold storage (S3) after 90 days |
| **OAuth token refresh** | Background cron job, not on-request |
| **Rate limiting** | Move from in-memory to Redis-backed (shared across replicas) |

---

## User Review Required

> [!IMPORTANT]
> **Existing secrets exposed**: Your current [.env](file:///d:/Zia%20AI/.env) file contains real API keys for Gmail, Spotify, and Twilio in plain text. These should be rotated immediately and never committed to Git. The new architecture encrypts all tokens at rest and uses environment variables injected at deployment time.

> [!WARNING]
> **NeuralBypass removal**: The existing [NeuralBypass](file:///d:/Zia%20AI/main.py#20-34) class and `unrestricted_mode` flag will be completely removed. All actions will flow through the confirmation rules engine. There is no "bypass mode" in production.

> [!CAUTION]
> **Hardcoded contacts**: The existing phonebook and email directory in [zia_core.py](file:///d:/Zia%20AI/zia_core.py) will be replaced with a database-backed contacts system. You'll need to re-enter your contacts through the UI after migration.

---

## Verification Plan

### Automated Tests
1. **Backend unit tests**: `cd backend && python -m pytest tests/ -v`
   - Test action schema validation
   - Test confirmation engine rule evaluation
   - Test JWT token generation and validation
   - Test rate limiting middleware

2. **Docker build check**: `docker compose -f deploy/docker-compose.prod.yml build --no-cache`
   - Verify all containers build successfully

3. **Lint + type check**: `cd backend && mypy app/ && ruff check app/`

### Manual Verification
1. **Folder structure audit**: Visually review that all planned directories and files exist
2. **API contract review**: Open `/api/docs` (Swagger UI) in browser and verify all endpoints are registered
3. **Security checklist pass**: Walk through each item in the hardening checklist
4. **User**: Please test the OAuth flow by connecting Gmail through the UI after deployment
